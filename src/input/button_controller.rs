use embassy_rp::gpio::Pin;
use embassy_rp::{Peri, gpio};
use embassy_sync::blocking_mutex::raw::CriticalSectionRawMutex;
use embassy_sync::channel::{Channel, Receiver, Sender};
use embassy_time::Ticker;
use gpio::{Input, Level, Pull};

use crate::units::TimeExt as _;

use {defmt_rtt as _, panic_probe as _};

const POLLING_RATE_MS: u64 = 20;
const DEBOUNCE_CYCLES: u8 = 3; // Number of cycles to confirm a state change

/// Button events generated by the ButtonController
/// - Pushed: Button is pressed down
/// - Released: Button is released
#[derive(Clone, Copy, Debug, defmt::Format)]
pub enum ButtonEvent<AliasType> {
    Pushed(AliasType),
    Released(AliasType),
}

type EventChannel<AliasType, const BUTTON_EVENT_QUEUE_SIZE: usize> =
    Channel<CriticalSectionRawMutex, ButtonEvent<AliasType>, BUTTON_EVENT_QUEUE_SIZE>;
type EventSender<'a, AliasType, const BUTTON_EVENT_QUEUE_SIZE: usize> =
    Sender<'a, CriticalSectionRawMutex, ButtonEvent<AliasType>, BUTTON_EVENT_QUEUE_SIZE>;
type EventReceiver<'a, AliasType, const BUTTON_EVENT_QUEUE_SIZE: usize> =
    Receiver<'a, CriticalSectionRawMutex, ButtonEvent<AliasType>, BUTTON_EVENT_QUEUE_SIZE>;

/// Internal state machine for button debouncing and event detection
/// - Idle: Button is not pressed
/// - Falling: Button press detected, waiting for debounce
/// - Low: Button is confirmed pressed
/// - Rising: Button release detected, waiting for debounce
/// - High: Button is confirmed released
///
/// **Note**:  The low and high states are referred to button states, not the electrical levels - high,
///        button released (input high), low - button pressed (input low), depending on pull-up or
///        pull-down configuration. For the pull down configuration, the logic is inverted.
#[derive(Clone, Copy)]
enum ButtonState {
    Idle,    // The state when button is not pressed (Actually High)
    Pressed, // The state when button is confirmed pressed
}

struct Button<AliasType = u8> {
    input: Input<'static>,
    alias: AliasType,
    pull: Pull,
}

pub struct ButtonControllerState<
    AliasType,
    const INPUTS: usize,
    const BUTTON_EVENT_QUEUE_SIZE: usize,
> {
    event_channel: EventChannel<AliasType, BUTTON_EVENT_QUEUE_SIZE>,
}

impl<const INPUTS: usize, AliasType, const BUTTON_EVENT_QUEUE_SIZE: usize>
    ButtonControllerState<AliasType, INPUTS, BUTTON_EVENT_QUEUE_SIZE>
{
    pub fn new() -> Self {
        Self {
            event_channel: Channel::new(),
        }
    }
}

#[derive(Clone, Copy)]
pub struct ButtonController<'a, AliasType, const BUTTON_EVENT_QUEUE_SIZE: usize>
where
    AliasType: 'static,
{
    receiver: EventReceiver<'a, AliasType, BUTTON_EVENT_QUEUE_SIZE>,
}

impl<'a, AliasType, const BUTTON_EVENT_QUEUE_SIZE: usize>
    ButtonController<'a, AliasType, BUTTON_EVENT_QUEUE_SIZE>
where
    AliasType: 'static,
{
    /// Asynchronously receives the next button event
    pub async fn receive(&self) -> ButtonEvent<AliasType> {
        self.receiver.receive().await
    }
}

pub struct ButtonControllerBuilder<const INPUTS: usize, AliasType = u8> {
    buttons: heapless::Vec<Button<AliasType>, INPUTS>,
}

impl<const INPUTS: usize, AliasType> ButtonControllerBuilder<INPUTS, AliasType> {
    pub fn new() -> Self {
        Self {
            buttons: heapless::Vec::new(),
        }
    }

    /// Binds a pin to the button controller with the specified alias and pull configuration
    /// - alias: An identifier for the button (e.g., enum or integer)
    /// - pin: The GPIO pin to bind
    /// - pull: The pull configuration for the button (Pull::Up, Pull::Down, Pull::None)
    ///   Note: Pull::None assumes active low configuration - button press pulls the line low
    pub fn bind_pin(&mut self, alias: AliasType, pin: Peri<'static, impl Pin>, pull: Pull) {
        if self.buttons.is_full() {
            panic!("ButtonControllerBuilder: Exceeded maximum number of buttons");
        }

        let mut input = Input::new(pin, pull);
        input.set_schmitt(true);
        let _ = self.buttons.push(Button { input, alias, pull });
    }

    /// Builds the ButtonController and ButtonControllerRunner
    /// - state: The shared ButtonControllerState
    /// Returns: (ButtonController, ButtonControllerRunner)
    pub fn build<'a, const BUTTON_EVENT_QUEUE_SIZE: usize>(
        self,
        state: &'a ButtonControllerState<AliasType, INPUTS, BUTTON_EVENT_QUEUE_SIZE>,
    ) -> (
        ButtonController<'a, AliasType, BUTTON_EVENT_QUEUE_SIZE>,
        ButtonControllerRunner<'a, AliasType, INPUTS, BUTTON_EVENT_QUEUE_SIZE>,
    ) {
        (
            ButtonController {
                receiver: state.event_channel.receiver(),
            },
            ButtonControllerRunner {
                buttons: self.buttons,
                sender: state.event_channel.sender(),
            },
        )
    }
}

enum Edge {
    Rising,
    Falling,
}

/// Type alias for cycle count
type Cycles = u8;

struct EdgeDetector {
    previous_level: Level,
    cycles: Cycles,
}

impl EdgeDetector {
    pub const fn new(initial_level: Level) -> Self {
        Self {
            previous_level: initial_level,
            cycles: 0,
        }
    }

    pub fn update_level(&mut self, level: Level) -> Option<Edge> {
        let result = if self.previous_level != level {
            if self.cycles < DEBOUNCE_CYCLES {
                self.cycles += 1;
                return None;
            }

            let edge = if level == Level::High {
                Edge::Rising
            } else {
                Edge::Falling
            };

            self.previous_level = level;
            Some(edge)
        } else {
            None
        };

        self.cycles = 0;

        result
    }
}

pub struct ButtonControllerRunner<
    'a,
    AliasType,
    const INPUTS: usize,
    const BUTTON_EVENT_QUEUE_SIZE: usize,
> where
    AliasType: 'a,
{
    buttons: heapless::Vec<Button<AliasType>, INPUTS>,
    sender: EventSender<'a, AliasType, BUTTON_EVENT_QUEUE_SIZE>,
}

impl<'a, const INPUTS: usize, AliasType, const BUTTON_EVENT_QUEUE_SIZE: usize>
    ButtonControllerRunner<'a, AliasType, INPUTS, BUTTON_EVENT_QUEUE_SIZE>
{
    pub async fn run(&self) -> !
    where
        AliasType: Copy,
    {
        // The default buttons pooling rate is set to 10Hz (100ms)
        // This rate is used to detect an initial button press.
        let mut ticker = Ticker::every((POLLING_RATE_MS).ms());

        // Initialize edge detectors for each button
        let mut edge_detectors = self
            .buttons
            .iter()
            .map(|button| {
                let initial_level = button.input.get_level();
                EdgeDetector::new(initial_level)
            })
            .collect::<heapless::Vec<_, INPUTS>>();

        loop {
            ticker.next().await;

            // Process each button
            for (i, button) in self.buttons.iter().enumerate() {
                let level = button.input.get_level();
                // Update edge detector
                if let Some(edge) = edge_detectors[i].update_level(level) {
                    let button_alias = button.alias;
                    let event = match (edge, button.pull) {
                        (Edge::Falling, Pull::Up) => ButtonEvent::Pushed(button_alias),
                        (Edge::Falling, Pull::Down) => ButtonEvent::Released(button_alias),
                        (Edge::Rising, Pull::Up) => ButtonEvent::Released(button_alias),
                        (Edge::Rising, Pull::Down) => ButtonEvent::Pushed(button_alias),
                        // Default case (no pull). Assume Pull::None means active low
                        (Edge::Rising, Pull::None) => ButtonEvent::Released(button_alias),
                        (Edge::Falling, Pull::None) => ButtonEvent::Pushed(button_alias),
                    };
                    self.sender.send(event).await;
                }
            }
        }
    }
}
